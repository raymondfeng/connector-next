/*** Generated by streamline 0.1.35 - DO NOT EDIT ***/

"use strict";
var __global = typeof global !== 'undefined' ? global : window;
function __cb(_, fn){ var ctx = __global.__context; return function(err, result){ __global.__context = ctx; if (err) return _(err); return fn(null, result); } }
function __future(fn, args, i){ var done, err, result; var cb = function(e, r){ done = true; err = e, result = r; }; args = Array.prototype.slice.call(args); args[i] = function(e, r){ cb(e, r); }; fn.apply(this, args); return function(_){ if (done) _.call(this, err, result); else cb = _.bind(this); } .bind(this); }
function __nt(_, fn){ var i = 0; var cb = __cb(_, fn); var safeCb = function(){ try { cb(); } catch (ex) { __propagate(cb, ex); } }; if (typeof process != "undefined" && typeof process.nextTick == "function") return function(){ if (++i % 20 == 0) process.nextTick(safeCb); else cb(); }; else return function(){ if (++i % 20 == 0) setTimeout(safeCb); else cb(); }; }
function __propagate(_, err){ try { _(err); } catch (ex) { __trap(ex); } }
function __trap(err){ if (err) { if (__global.__context && __global.__context.errorHandler) __global.__context.errorHandler(err); else console.error("UNCAUGHT EXCEPTION: " + err.message + "\n" + err.stack); } }
var parseUrl = require("url").parse;
function _reply(callback, err, value) {
  try {
    callback(err, value);
  } catch (ex) {
    __propagate(callback, ex);
  };
};
function checkOpen(emitter) {
  if (!emitter) {
    throw new Error("invalid operation on closed stream")
  };
};
function wrapProperties(constr, writable, props) {
  props.forEach(function(name) {
    constr.prototype.__defineGetter__(name, function() {
      return this.emitter[name];
    });
  });
  (writable && props.forEach(function(name) {
    constr.prototype.__defineSetter__(name, function(val) {
      this.emitter[name] = val;
      return this;
    });
  }));
};
function wrapMethods(constr, methods) {
  methods.forEach(function(name) {
    constr.prototype[name] = function() {
      return this.emitter[name].apply(this.emitter, arguments);
    };
  });
};
function wrapChainMethods(constr, methods) {
  methods.forEach(function(name) {
    constr.prototype[name] = function() {
      this.emitter[name].apply(this.emitter, arguments);
      return this;
    };
  });
};
function wrapEvents(constr, events) {
  constr.prototype.events = ((constr.prototype.events || [])).concat(events);
};
function Emitter(emitter) {
  emitter.on("close", function() {
    _onClose();
  });
  function trackClose() {
    emitter = null;
  };
  var _onClose = trackClose;
  this.close = function(callback) {
    if (!callback) {
      return __future.call(this, this.close, arguments, 0)
    };
    if (!emitter) {
      return _reply(callback)
    };
    var close = (emitter.close || emitter.destroySoon);
    if ((typeof close !== "function")) {
      return _reply(callback)
    };
    _onClose = function() {
      emitter = null;
      _onClose = trackClose;
      _reply(callback);
    };
    if (this.doesNotEmitClose) {
      emitter.emit("close");
    };
    close.call(emitter);
  };
  this.__defineGetter__("emitter", function() {
    return emitter;
  });
  this.unwrap = function() {
    var result = emitter;
    (emitter && emitter.events.forEach(function(event) {
      emitter.removeAllListeners(event);
    }));
    emitter = null;
    return result;
  };
};
function ReadableStream(emitter, options) {
  Emitter.call(this, emitter);
  options = (options || {
  });
  var _low = Math.max((options.lowMark || 0), 0);
  var _high = Math.max((options.highMark || 0), _low);
  var _paused = false;
  var _current = 0;
  var _chunks = [];
  var _error;
  var _done = false;
  var _encoding;
  emitter.on("error", function(err) {
    _onData(err);
  });
  emitter.on("data", function(chunk) {
    _onData(null, chunk);
  });
  emitter.on("end", function() {
    _onData(null, null);
  });
  function trackData(err, chunk) {
    if (!emitter) {
      return
    };
    if (err) {
      _error = err;
    } else {
      if (chunk) {
        _chunks.push(chunk);
        _current += chunk.length;
        if (((((_current > _high) && !_paused) && !_done) && !_error)) {
          emitter.pause();
          _paused = true;
        }
      ;
      }
       else _done = true;
    
    };
  };
  var _onData = trackData;
  function readChunk(callback) {
    if ((_chunks.length > 0)) {
      var chunk = _chunks.splice(0, 1)[0];
      _current -= chunk.length;
      if (((((_current <= _low) && _paused) && !_done) && !_error)) {
        emitter.resume();
        _paused = false;
      }
    ;
      return _reply(callback, null, chunk);
    }
     else if (_done) {
      return _reply(callback, null, null);
    } else {
      if (_error) {
        return _reply(callback, _error);
      } else {
        _onData = function(err, chunk) {
          if (err) {
            _error = err;
          } else {
            if (!chunk) {
              _done = true;
            }
          };
          _onData = trackData;
          _reply(callback, err, chunk);
        };
      }
    }
  ;
  };
  function concat(chunks, total) {
    if (_encoding) {
      return chunks.join("")
    };
    if ((chunks.length == 1)) {
      return chunks[0]
    };
    var result = new Buffer(total);
    chunks.reduce(function(val, chunk) {
      chunk.copy(result, val);
      return (val + chunk.length);
    }, 0);
    return result;
  };
  this.setEncoding = function(enc) {
    checkOpen(emitter);
    _encoding = enc;
    if (enc) {
      emitter.setEncoding(enc);
    };
    return this;
  };
  this.read = function __1(_, len) {
    if (!_) {
      return __future.call(this, __1, arguments, 0);
    }
  ;
    var chunks, total, chunk, __this = this;
    if (!emitter) {
      return _(null, null);
    }
  ;
    return (function(__then) {
      if ((len == null)) {
        return readChunk(_);
      }
       else {
        __then();
      }
    ;
    })(function() {
      if ((len < 0)) {
        len = Infinity;
      }
    ;
      if ((len == 0)) {
        return _(null, (_encoding ? "" : new Buffer(0)));
      }
    ;
      chunks = [];
      total = 0;
      return (function(__break) {
        var __loop = __nt(_, function() {
          var __4 = (total < len);
          if (__4) {
            return readChunk(__cb(_, function(__0, __2) {
              chunk = __2;
              if (!chunk) {
                return _(null, ((chunks.length == 0) ? null : concat(chunks, total)));
              }
            ;
              if (((total + chunk.length) <= len)) {
                chunks.push(chunk);
                total += chunk.length;
              }
               else {
                chunks.push(chunk.slice(0, (len - total)));
                __this.unread(chunk.slice((len - total)));
                total = len;
              }
            ;
              __loop();
            }));
          }
           else {
            __break();
          }
        ;
        });
        __loop();
      })(function() {
        return _(null, concat(chunks, total));
      });
    });
  };
  this.readAll = function __2(_) {
    if (!_) {
      return __future.call(this, __2, arguments, 0);
    }
  ;
    var __this = this;
    return __this.read(_, -1);
  };
  this.unread = function(chunk) {
    if (chunk) {
      _chunks.splice(0, 0, chunk);
      _current += chunk.length;
    }
  ;
    return this;
  };
};
exports.ReadableStream = ReadableStream;
wrapEvents(ReadableStream, ["error","data","end","close",]);
function WritableStream(emitter, options) {
  Emitter.call(this, emitter);
  options = (options || {
  });
  var _drainCallback;
  emitter.on("drain", function() {
    var callback = _drainCallback;
    if (callback) {
      _drainCallback = null;
      _reply(callback);
    }
  ;
  });
  function _drain(callback) {
    _drainCallback = callback;
  };
  this.write = function __1(_, data, enc) {
    if (!_) {
      return __future.call(this, __1, arguments, 0);
    }
  ;
    var __this = this;
    checkOpen(emitter);
    return (function(__then) {
      if (!emitter.write(data, enc)) {
        return _drain(__cb(_, __then));
      }
       else {
        __then();
      }
    ;
    })(function() {
      return _(null, __this);
    });
  };
  this.end = function(data, enc) {
    checkOpen(emitter);
    emitter.end(data, enc);
    return this;
  };
};
exports.WritableStream = WritableStream;
wrapEvents(WritableStream, ["drain","close",]);
function _getEncoding(headers) {
  var comps = ((headers["content-type"] || "text/plain")).split(";");
  var ctype = comps[0];
  for (var i = 1; (i < comps.length); i++) {
    var pair = comps[i].split("=");
    if (((pair.length == 2) && (pair[0].trim() == "charset"))) {
      return pair[1].trim()
    };
  };
  if (((ctype.indexOf("text") >= 0) || (ctype.indexOf("json") >= 0))) {
    return "utf8"
  };
  return null;
};
function HttpServerRequest(req, options) {
  ReadableStream.call(this, req, options);
  this._request = req;
  this.setEncoding(_getEncoding(req.headers));
};
exports.HttpServerRequest = HttpServerRequest;
HttpServerRequest.prototype.doesNotEmitClose = true;
wrapProperties(HttpServerRequest, true, ["method","url","headers","trailers","httpVersion","connection","socket",]);
function HttpServerResponse(resp, options) {
  WritableStream.call(this, resp, options);
  this._response = resp;
};
exports.HttpServerResponse = HttpServerResponse;
HttpServerResponse.prototype.doesNotEmitClose = true;
wrapChainMethods(HttpServerResponse, ["writeContinue","writeHead","setHeader","removeHeader","addTrailers",]);
wrapMethods(HttpServerResponse, ["getHeader",]);
wrapProperties(HttpServerResponse, true, ["statusCode",]);
function _fixHttpServerOptions(options) {
  options = (options || {
  });
  options.module = require((options.secure ? "https" : "http"));
  return options;
};
function HttpServer(requestListener, options) {
  var self = this;
  options = _fixHttpServerOptions(options);
  var server = options.module.createServer(function(request, response) {
    return requestListener(new HttpServerRequest(request, options), new HttpServerResponse(response, options), function(err) {
      if (err) {
        response.writeHead(500, {
          "Content-Type": "text/plain"
        });
        response.end(((err.message + "\n") + err.stack));
      }
    ;
    });
  });
  Emitter.call(this, server);
  this.listen = function(callback, args) {
    if (!callback) {
      return __future.call(this, this.listen, arguments, 0)
    };
    args = Array.prototype.slice.call(arguments, 1);
    args.push(function() {
      _reply(callback, null, self);
    });
    server.listen.apply(server, args);
  };
};
exports.HttpServer = HttpServer;
function HttpClientResponse(resp, options) {
  ReadableStream.call(this, resp, options);
  this._response = resp;
  this.setEncoding(_getEncoding(resp.headers));
};
wrapProperties(HttpClientResponse, false, ["statusCode","httpVersion","headers","trailers",]);
HttpClientResponse.prototype.checkStatus = function(statuses) {
  if ((typeof statuses === "number")) {
    statuses = [statuses,];
  };
  if ((statuses.indexOf(this.statusCode) < 0)) {
    throw new Error(("invalid status: " + this.statusCode))
  };
  return this;
};
function _fixHttpClientOptions(options) {
  if (!options) {
    throw new Error("request error: no options")
  };
  if ((typeof options === "string")) {
    options = {
      url: options
    };
  };
  if (options.url) {
    var parsed = parseUrl(options.url);
    options.protocol = parsed.protocol;
    options.host = parsed.hostname;
    options.port = parsed.port;
    options.path = (parsed.pathname + ((parsed.query ? ("?" + parsed.query) : "")));
  }
;
  options.protocol = (options.protocol || "http:");
  options.port = (options.port || (((options.protocol === "https:") ? 443 : 80)));
  options.path = (options.path || "/");
  if (!options.host) {
    throw new Error("request error: no host")
  };
  options.method = (options.method || "GET");
  options.headers = (options.headers || {
  });
  options.module = require(options.protocol.substring(0, (options.protocol.length - 1)));
  if ((options.user != null)) {
    var token = ((options.user + ":") + ((options.password || "")));
    token = new Buffer(token, "utf8").toString("base64");
    options.headers.Authorization = ("Basic " + token);
  }
;
  if (options.proxy) {
    if ((typeof options.proxy === "string")) {
      options.proxy = parseUrl(options.proxy);
      options.proxy.host = options.proxy.hostname;
    }
  ;
    options.proxy.port = (options.proxy.port || options.port);
    if (!options.proxy.host) {
      throw new Error("proxy configuration error: no host")
    };
    options.path = (((((options.protocol + "//") + options.host) + ":") + options.port) + options.path);
    options.headers.host = options.host;
    options.host = options.proxy.host;
    options.port = options.proxy.port;
  }
;
  return options;
};
function HttpClientRequest(options) {
  options = _fixHttpClientOptions(options);
  var _request = options.module.request(options, function(resp) {
    _onResponse(null, (resp && new HttpClientResponse(resp, options)));
  });
  WritableStream.call(this, _request, options);
  var _response;
  var _error;
  var _done = false;
  _request.on("error", function(err) {
    (!_response && _onResponse(err));
  });
  function trackResponse(err, resp) {
    _done = true;
    _error = err;
    _response = resp;
  };
  var _onResponse = trackResponse;
  this.response = function(callback) {
    if (!callback) {
      return __future.call(this, this.response, arguments, 0)
    };
    if (_done) {
      return _reply(callback, _error, _response);
    } else {
      _onResponse = function(err, resp) {
        _reply(callback, err, resp);
      };
    };
  };
};
wrapChainMethods(HttpClientRequest, ["abort",]);
exports.httpRequest = function(options) {
  return new HttpClientRequest(options);
};
function NetStream(emitter, options) {
  ReadableStream.call(this, emitter, (options.read || options));
  WritableStream.call(this, emitter, (options.write || options));
};
exports.NetStream = NetStream;
var net;
exports.tcpClient = function(port, host, options) {
  host = (host || "localhost");
  options = (options || {
  });
  return new NetClient(options, port, host);
};
exports.socketClient = function(path, options) {
  options = (options || {
  });
  return new NetClient(options, path);
};
function NetClient(options, args) {
  args = Array.prototype.slice.call(arguments, 1);
  net = (net || require("net"));
  var _connection = net.createConnection.apply(net, args);
  var _error;
  var _done = false;
  _connection.on("error", function(err) {
    _onConnect(err);
  });
  _connection.on("connect", function() {
    _onConnect(null);
  });
  function trackConnect(err) {
    _done = true;
    _error = err;
  };
  var _onConnect = trackConnect;
  this.connect = function(callback) {
    if (!callback) {
      return __future.call(this, this.connect, arguments, 0)
    };
    if (_done) {
      return _reply(callback, _error, new NetStream(_connection, options));
    } else {
      _onConnect = function(err) {
        _reply(callback, err, new NetStream(_connection, options));
      };
    };
  };
};